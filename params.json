{
  "name": "CPPBridge - A Bridge between Pharo and C++ using shared memory mapped files",
  "tagline": "",
  "body": "# CPPBridge\r\n\r\n\r\nhttps://youtu.be/pI4PR3XaX6Q\r\n\r\n------\r\n# What is it ?\r\n\r\nCPPBridge is a library that allows Pharo to share memory with any C/C++ application. Opening the door not\r\nonly to IPC and data sharing but also even complete control of C++ code from Pharo and vice versa.\r\n\r\n------\r\n# Documentation\r\n\r\nCPPBridge class has a comment with all the details, each method at class side is commented , there is also \r\nan example method . C++ files required for the example files are included with the repo, you have just to \r\ncompile them and execute Atlas-server.\r\n\r\n------\r\n## How to install ?\r\n\r\nIn a few hours it should be available from Package Browser, if you like to install it manually then open a \r\nPlayground inside Pharo and do the following command\r\n\r\n```Smalltalk\r\nMetacello new baseline:\r\n'CPPBridge' ; repository: 'github://kilon/CPPBridger:master';load.\r\n```\r\n---------\r\n## How to use it ?\r\nYou need to first build atlas-server.cpp which you can do with\r\n```\r\ng++ atlas-server.cpp -o atlas-server\r\n```\r\nthen execute it\r\n```\r\n./atlas-server\r\n```\r\nit will ask you to type a string, type whatever you like and press enter. Will provide information about the C\r\nstruct which is used to store data into the shared memory. Basically this application is opening / creating a \r\nfile called \"mmaped.bin\" which  is just a simple binary file and maps it to the memory. That means that whatever\r\nis in the file is loaded to the memory. \r\n\r\nThen shares the memory with any other process who will memory map the same file. \r\n\r\nThen we start Pharo , install CPPBridge to it and go to CPPBridge class >> retrieveSharedValueStep1 , read \r\nthe comment and click the green triangle to execute so that you receive the C string you typed from Pharo \r\nand then execute retrieveSharedValueStep2 to unmap and close the file\r\n\r\nBellow is the source of both methods together with their comments.\r\n````Smalltalk\r\nretrieveSharedValueStep1\r\n<example>\r\n\"\r\nThis method is an example that retrieves a struct from a shared memory\r\nsection, in order for this example to work you need you first copy\r\npaste the contents of the Example Souce Code of the C++ file in the\r\ncomment section (you can also find the cpp file in the same directory\r\nwhere the git repo has been downloaded) of this class to a C++ source\r\ncode file and compile it a run then replace the path of in this code\r\nof CPPBridge openFile: with the correct path of the bin that the C++\r\nfiles has created , in order for this to work also you need to execute\r\nthe C++ example first so it creates and file and share the memory.\r\n\r\nAfter executing this method you can execute retrieveSharedValueStep2\r\nto unmap and close the memory mapped file (keeps sharing the memory it\r\njust does not store it to the file)\"\r\n\r\n|instance fdNumber lseek mmapPointer data struct|\r\n\r\n\"Let's create an instance just an an example but we wont use it\r\nbecause we can use either class method or intance methods. You would\r\nwant to use instance method if you want to open multiple memory mapped\r\nfiles meaning multiple areas of shared memory. Class methods for using\r\njust one\"\r\n\r\ninstance := CPPBridge new.\r\n\r\n\"Warning !!! You must change the path to the file that is located in\r\nyour hard drive.  The file should be at the same location you built\r\natlas-server.cpp which is responsible for creating the file. The\r\nnumber returned is a number that OS uses to identify the image , flag\r\nO_RDWR is just a number that states that we want to write and read the\r\nfile\"\r\n\r\nfdNumber := CPPBridge openFile:'/Users/kilon/git/Pharo/Atlas/mmapped.bin' \r\n                     flags: (O_RDWR) .\r\n\r\n\"lseek is used to stretch the file to a new size\" \r\n\r\nlseek := CPPBridge\r\nlSeek_fd: fdNumber range:3999 value:0.\r\n\r\n\"this is the most importan method, this method maps the file to\r\nmemmory , which means it loads its contents into memory and associates\r\nthe memory with the file. PROT_READ means we want to write the memory\r\n, PROT_WRITE to write the memory and MAP_SHARED is the most importan\r\nbecause it defines the memory area as shared so we can access it from\r\nother application\"\r\n\r\nmmapPointer := CPPBridge mmap_adress: 0 fileSize:4000\r\n                          flag1: (PROT_READ | PROT_WRITE )flag2:\r\n                          MAP_SHARED fd: fdNumber offset: 0 .\r\n\r\n\"This assigns the pointer to our Pharo structure so we can use it to\r\nget the contents of the C structure located in the shared memory\"\r\n\r\nstruct := CPPStruct pointTo: (mmapPointer getHandle ).\r\n\r\n\"data here serves as a convenience array its not necessary we use it\r\njust to collect information about the instance, the fd number of the\r\nfile, the streched size of the file, the adress (point) where the file\r\nis mapped to in memory and structthat contains the values of the C\r\nstruct that we received\" \r\n\r\ndata :={ instance.  fdNumber. lseek. mmapPointer .  struct}.  \r\ndata inspect.\r\n\r\n\"Store data to the class so we can use it in the second method\"\r\n\r\nExampleDATA := data.  \r\n\r\n^data\r\n\r\n\" Its also possible to write to the shared memory , in this case we\r\nuse once again the C struct which has the following members\r\n(variables) :\r\n\r\n1) data = char[3000] this is where we store the string \r\n2) count = int this is where we store the size of the string\r\n\r\nstruct := {(mmapPointer getHandle copyFrom: 1 to:3000 )asString .\r\n            (mmapPointer getHandle integerAt: 3001 size:4 signed:\r\n            false)}.\r\n\r\nmmapPointer is the pointer that points to the first byte of the shared\r\nmemory.\r\n\r\ngetHandle gives us the memory address that the pointer points to\r\n\r\ncopyFrom:1 to:3000 copies byte from byte 0 (remember C counts from 0 ,\r\nPharo counts from 1) to byte 3000 because the string we store is\r\nstored as a char array of 3000 elements, each element is a char, each\r\nchar is 1 byte in legth and represents a single character of the\r\nstring. This gets the value of the first struct member.\r\n\r\non the other hand integerAt: 3001 size: 4 signed: false returns us the\r\nvalue count member of the C struct . its an integer in position 3001\r\nbecause our string is a char[3000] and the size is 4 bytes because its\r\nan C int, signed false because we use no negative values because it\r\ndoes not make sense for a string to have negative length. This gets\r\nthe value of the second struct member\" \r\n\r\n\r\nretrieveSharedValueStep2 \r\n<example> \r\n\r\n\"\r\nthis one is to be triggered after retrieveSharedValueStep1 when we are\r\nfinished with the shared memory and we want to erase it and close the \r\nmemory mapped file\r\n\r\nExampleDATA here severs as convenience array for storing the return\r\nvalues from the call to C function.\r\n\r\nfd -> a number with which the OS identifies the memory mapped file\r\n\r\nlseek -> a number that returns the size of the file after we stretched\r\nit to its finaly size\r\n\r\nmmap -> this is the juice, the pointer that points to the first byte\r\nof the shared memory. The final byte is of the shared memory defined\r\nby the size of the file.\r\n\r\nstruct -> here we put the values we retrieved from the C struct which\r\nwas the goal of the previous method\r\n\r\nExampleDATA = { CPPBridgeinstance . fd . lseek . mmap . struct}\"\r\n\r\n\"first lets unmap the file, basically this will disassociate the file\r\nwith the memory area that is assigned to ,meaning the OS will no longer\r\nstore in that file automatically what we change in shared memory\"\r\n\r\nCPPBridge munmap_data: (ExampleDATA at: 4) filesize: 4000.\r\n\r\n\"And because we wont be using the file anymore lets close. Remember\r\nyou still have access to the shared memmory. \"\r\n\r\nCPPBridge closeFile: (ExampleDATA at: 2).  \r\n\r\n```\r\n\r\n-----\r\n# Why bother making such a library ? \r\n\r\nIn my saga to find a way to use Pharo as a scripting language for Unreal Game Engine, I had two options\r\n\r\n1. Build Unreal as a Library and use Pharo UFFI to launch and control it\r\n1. Embed Pharo inside the Unreal Executable (this is what every other scripting language uses for controlling Unreal) \r\n\r\nOption a was a no go, because Unreal is huge , complex and uses its own custom made build tools, making a DLL for Pharo or an army of DLLs  out of the question\r\n\r\nOption b Embeding Pharo inside an executable is impossible and implementing it also insanely complex.Naturally my mind went first into sockets which is what I use to make Pharo able to use Python libraries. However sockets have proven too slow for the insanely fast loops of Unreal. \r\n\r\n-----\r\n# What are the advantages ?\r\n\r\n* No need to move data around. Sharing memory means you don't have to move data around, you can use directly the shared memory\r\n\r\n* Extend the Pharo image beyond Pharo. Shared memory is mapped into a file means that you can do with C++ what you can do with Pharo image, save the live state directly to a binary file. That means we no longer need to worry about sessions and reinitializing C/C++ data since memory mapped file acts as an extension of the Pharo image. \r\n\r\n* Blazing fast. Memory mapping is a function that comes directly from the OS kernel and as such it has to be extremely fast. Memory mapping is also what is used for dynamically linked shared libraries an extremely important feature for any application including Pharo that heavily depends on (see Cairo for Athens). So its a very mature , well tested method. \r\n\r\n* No extra libraries needed to be installed, CPPBridge uses OS libraries to work out of the box\r\n\r\n* Low level handling of memory. Direct access to memory you can even manipulate the memory byte by byte\r\n\r\n* Memory efficient. Memory mapping excels at large data, the bigger the better. Can take full advantage of your entire free memory and not waste a byte.  That means also that can be used to optimise Pharo memory, since you could compress your Pharo objects to bytes and mapped file will store the live state.\r\n\r\n* Tons of Languages. Because memory mapping is a core functionality for every OS out there, pretty much every programming language supports it. CPPBridge currently supports only C/C++ but all languages can be supported giving access to Pharo to any library for any programming language. Sky is the limit\r\n\r\n* Self Documented. CPPBridge is small, simple and with large class comment and comments for every method. YouTube video tutorial also available and linked on top. \r\n\r\n* Works both ways, C/C++ and Pharo can access and modify the shared memory. Making it possible for C/C++ to use Pharo libraries and Pharo to use C/C++ libraries.\r\n\r\n* Experiments have proven that it improves sex life...  if it does not please file a bug report ;)\r\n\r\n-----\r\n# What are the disadvantages ?\r\n\r\n* Candy Crash Saga. Dare do something incorrectly and Pharo will crash. CPPBridge can easily point to wrong address if you are not aware of what you doing. \r\n\r\n* C++/C . If you think you can avoid learning C/C++ and that this is a magic solution , think again. The C/C++ application must be modified to include shared memory mapping for CPPBridge to work .\r\n\r\n* Local only. Unlike sockets, Shared Memory works only on the same machine so no remote execution and manipulation of code like in my socket bridge to Python\r\n\r\n* UFFI still No1 option. No replacement for UFFI it actually depends on it to work , so if you can turn your C/C++ code into a DLL that should be your first option.\r\n\r\n-----\r\n# Roadmap \r\n\r\nCurrently CPPBridge works only on MacOS , most likely on Linux too (because it uses the Unix architecture) but I will have to test it.\r\n\r\nWindows is coming next ASAP, since its my No1 platform for creating commercial games.\r\n\r\nMaybe establish a small protocol of communication via the Shared Memory , JSON looks like a good universal format \r\n\r\n-----\r\n# Thanks\r\n\r\nBig thanks to Eliot for inspiring me and Esteban for helping me figure out things.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}